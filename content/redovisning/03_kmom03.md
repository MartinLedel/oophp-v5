---
---
Redovisning kmom03
=========================

__Innan oopython kursen__ hade jag aldrig skrivit enhetstester förut. Pythons unittest och PHPs phpunit var väldigt lika så det hjälpte att komma igång med phpunit. Intrycken är att det är ett bra verktyg att se till att sin kod gör som det är tänkt. Som Mikael sa på föreläsningen kan det också vara bra att göra testerna först så man vet vad som förväntas ur sin kod. Annars måste man gå tillbaka och ändra sin kod för att göra den testbar.

__Som jag skrev__ ovan är det viktigt att veta vad som förväntas av sin kod så man kan skriva "testbar kod". I början tänkte jag att enhet menade varje "projekt" men insåg senare att det blev ungefär varje del av ett "projekt". I mina ögon är det viktiga att skriva just testbar kod. Man vill ändå att koden ska bete sig på ett visst sätt. Kan också förstå att vissa fall behöver man ha inte testbar kod, som vid inloggningar eller hantera känslig information. Utöver det tycker jag testarbar kod = bra skriven kod.

__White, grey och__ black box testing är olika begrepp hur man testar en "enhet". Men white box testar man själva funktionerna / metoderna. Som white box tester vet man hur koden är uppbyggd så då kan man testa en funktion/metod och veta hur ens testfall ska sluta. Black box testar är då det omvända. Som en black box tester så testar man själva enheten. Man testar så att enheten producerar rätt utfall. Man har ingen koll på koden under. Då är ju en grey box tester någon som är mitt emellan. Är någon som både har smått koll på hur funktionerna/metoderna fungerar samt enheten. När man testar så finns det både positiva och negativa tester. Positiva är när man får utfallet som funktioner/metoderna/enheten är tänkt att göra. Negativa är när villa "första" sin kod. Göra testfall som funktionera/metoderna/enheten inte var till för. Till exmpel man testar att trigga exceptions.

__När jag skulle__ bygga tärningsspelet fortsatte jag i samma tanke spår som i kmom02 med gissningsspelet i me-sidan. Det jag tänkte på sen dess var att mina routes var lite för stora för min smak. Så jag tog DiceHand och Dice klasserna från guiden och börja placera ut min kod i routes. Från kmom02 hade jag spelet i en play-guess route. Nu med tärningsspelet blev det alldeles förstår så tog då min tanke från kmom02 och gjorde en DiceHandler klass som skulle hantera spelarna, poängen och spelet. I DiceHandler så använde jag DiceHand för att få en fungerade roll dice metod. Förutom det hade jag en egen metod för datorn samt olika get metoden för att hämta ut värden och en metod för att spara poängen så dem inte försvinner.

I min init kör jag igång med en enkel roll med Dice klassen för att se vem som börjar. Väl i play.php routen så händer inte så mycket än att den fångar upp saker från sessionen och skickar till play.php. I min play.php POST route så fånga POST upp och kör en redirect till olika routes beroende på vad man tryckt på. Om datorn spelaren ska spela så skickas den till sin egna route, play-dice. Har hämtar jag spelet från sessionen, kör min metod för att rulla tärningarna samt hämtar poängen och den nuvarande spelaren samt en kontroll om man hamnar över 100 poäng och vinner. Om man tryckte på spara poäng skickas man till en egen route, save-score där setSavedScore() körs och hämtar den nya spelaren så rätt knapp visas. Om man då trycker på Simulera dator så går den till routen computer-dice. Fungerar på liknande sätt som routen för spelaren. Hämtar spelet från sessionen och kör simulateComputer(). Inuti den finns en begränsad logik som "datorn" ifall den ska spara poängen eller fortsätta rulla tärningar. Till slut finns det starta om knappen som går till routen start-over, vilket är en kopia av min init.

Allt som allt är jag nöjd med hur spelet blev. Har bra UX design med poängen, rullningarna och knapparna samt allt fungerade som det var tänkt (hittar inga kvarvarande buggar).

__Gick väldigt bra__ att testa mitt tärningsspelet. Hade alltid i åtanke att det skulle testas senare och ville ha bra coverage. Var såklart lite svårt att komma på testfall på mina olika enheter. Fick nästan 100% förutom på DiceHandler där det saknades två rader inuti en if sats.

__TIL blev att__ enhetstesterna var så likt hur man testar i python. Var liknande assertions, hur setUp och tearDown fungerade och hur man skulle tänka på testfallen.
